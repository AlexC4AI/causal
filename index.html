<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å› æœæ¨æ–­è¶£å‘³ç§‘æ™®åŠ¨ç”» (åº”ç”¨å¢å¼ºç‰ˆ)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: #f0f2f5;
        }
        .scene-text {
            transition: opacity 0.5s ease-in-out;
        }
        .control-button {
            transition: background-color 0.3s, transform 0.2s;
        }
        .control-button:hover {
            transform: translateY(-2px);
        }
        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .causal-node {
            cursor: pointer;
            transition: transform 0.3s ease;
        }
        .causal-node:hover {
            transform: scale(1.05);
        }
        .causal-link {
            stroke-width: 3;
            marker-end: url(#arrowhead);
            transition: opacity 0.5s ease;
        }
        .correlation-link {
            stroke-width: 4px;
            stroke-dasharray: 8 8;
            transition: opacity 0.5s ease;
        }
        .app-text {
            transition: opacity 0.5s ease-in-out;
        }
    </style>
</head>
<body class="bg-slate-100 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-white rounded-2xl shadow-xl p-6 md:p-8">
        <h1 class="text-2xl md:text-3xl font-bold text-center text-slate-800 mb-2">ç›¸å…³ä¸ç­‰äºå› æœï¼šå› æœæ¨æ–­</h1>
        <p class="text-center text-slate-500 mb-6"></p>

        <!-- Animation Canvas -->
        <div id="animation-canvas" class="relative w-full aspect-video bg-slate-50 rounded-lg overflow-hidden border border-slate-200">
            <svg id="main-svg" width="100%" height="100%"></svg>
        </div>

        <!-- Explanatory Text -->
        <div class="mt-6 text-center min-h-[8em] flex items-center justify-center px-4">
            <p id="scene-text" class="scene-text text-slate-700 text-lg leading-relaxed md:text-xl"></p>
        </div>

        <!-- Navigation Controls -->
        <div class="flex justify-center items-center space-x-4 mt-6">
            <button id="prev-btn" class="control-button bg-slate-300 text-slate-700 font-bold py-2 px-6 rounded-full shadow-md hover:bg-slate-400">ä¸Šä¸€æ­¥</button>
            <span id="scene-indicator" class="text-slate-500 font-mono">1 / 6</span>
            <button id="next-btn" class="control-button bg-blue-500 text-white font-bold py-2 px-6 rounded-full shadow-md hover:bg-blue-600">ä¸‹ä¸€æ­¥</button>
        </div>
    </div>
    
    <footer class="text-center mt-8 text-slate-400 text-sm">
        <p></p>
    </footer>

    <script>
        // --- Basic Setup ---
        const svg = d3.select("#main-svg");
        const width = svg.node().getBoundingClientRect().width;
        const height = svg.node().getBoundingClientRect().height;
        const sceneText = d3.select("#scene-text");
        const nextBtn = d3.select("#next-btn");
        const prevBtn = d3.select("#prev-btn");
        const sceneIndicator = d3.select("#scene-indicator");

        let currentScene = 0;
        let appInterval; // To control the interval in the last scene

        // --- Arrowhead definition for causal links ---
        svg.append('defs').append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '-0 -5 10 10')
            .attr('refX', 8)
            .attr('refY', 0)
            .attr('orient', 'auto')
            .attr('markerWidth', 8)
            .attr('markerHeight', 8)
            .attr('xoverflow', 'visible')
            .append('svg:path')
            .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
            .attr('fill', '#94a3b8')
            .style('stroke','none');

        // --- Scene Definitions ---
        const scenes = [
            // Scene 1: The Illusion of Causation
            {
                text: "å¤å¤©åˆ°äº†ï¼Œæˆ‘ä»¬å‘ç°ä¸€ä¸ªå¥‡æ€ªçš„ç°è±¡ï¼šå†°æ·‡æ·‹å–å¾—è¶Šå¤šï¼Œæººæ°´çš„äººä¹Ÿè¶Šå¤šã€‚éš¾é“åƒå†°æ·‡æ·‹ä¼šå¯¼è‡´æººæ°´å—ï¼Ÿ",
                action: () => {
                    svg.selectAll("*").remove(); // Clear previous scene
                    const g = svg.append("g");
                    const data = [{ label: "å†°æ·‡æ·‹é”€é‡", icon: "ğŸ¦", x: width * 0.25, y: height * 0.5 }, { label: "æººæ°´äººæ•°", icon: "ğŸŠ", x: width * 0.75, y: height * 0.5 }];
                    const nodes = g.selectAll(".node").data(data).enter().append("g").attr("class", "node").attr("transform", d => `translate(${d.x}, ${d.y})`);
                    nodes.append("rect").attr("x", -60).attr("y", -40).attr("width", 120).attr("height", 80).attr("rx", 15).attr("fill", "white").attr("stroke", "#e2e8f0").attr("stroke-width", 2);
                    nodes.append("text").text(d => d.icon).attr("font-size", "40px").attr("text-anchor", "middle").attr("y", 5);
                    nodes.append("text").text(d => d.label).attr("text-anchor", "middle").attr("y", 30).style("font-size", "14px");
                    const correlationLink = g.append("line").attr("class", "correlation-link").attr("x1", data[0].x + 60).attr("y1", data[0].y).attr("x2", data[1].x - 60).attr("y2", data[1].y).attr("stroke", "#f87171");
                    correlationLink.style("opacity", 0).transition().duration(500).delay(500).style("opacity", 1);
                    g.append("text").text("ä»…ä»…æ˜¯ç›¸å…³ â†’").attr("x", data[0].x + 70).attr("y", data[0].y - 10).attr("fill", "#f87171").style("opacity", 0).transition().duration(500).delay(800).style("opacity", 1);
                }
            },
            // Scene 2: Unmasking the Confounder
            {
                text: "å½“ç„¶ä¸æ˜¯ï¼è¿™åªæ˜¯ç›¸å…³æ€§ï¼Œä¸æ˜¯å› æœå…³ç³»ã€‚çœŸæ­£çš„åŸå› æ˜¯èƒŒåéšè—çš„â€œæ··æ‚å› ç´ â€â€”â€”ç‚çƒ­çš„å¤©æ°”ã€‚",
                action: () => {
                    svg.selectAll("*").remove();
                    const g = svg.append("g");
                    svg.select("defs").html('<marker id="arrowhead" viewBox="-0 -5 10 10" refX="8" refY="0" orient="auto" markerWidth="8" markerHeight="8" xoverflow="visible"><path d="M 0,-5 L 10 ,0 L 0,5" fill="#94a3b8" style="stroke:none;"></path></marker>');
                    const nodesData = [{ id: 1, label: "å†°æ·‡æ·‹é”€é‡", icon: "ğŸ¦", x: width * 0.25, y: height * 0.7 }, { id: 2, label: "æººæ°´äººæ•°", icon: "ğŸŠ", x: width * 0.75, y: height * 0.7 }, { id: 3, label: "ç‚çƒ­å¤©æ°”", icon: "â˜€ï¸", x: width * 0.5, y: height * 0.25 }];
                    const correlationLink = g.append("line").attr("class", "correlation-link").attr("x1", nodesData[0].x + 60).attr("y1", nodesData[0].y).attr("x2", nodesData[1].x - 60).attr("y2", nodesData[1].y).attr("stroke", "#f87171").style("opacity", 1);
                    correlationLink.transition().duration(500).delay(1000).style("opacity", 0).remove();
                    const nodes = g.selectAll(".node").data(nodesData).enter().append("g").attr("class", "causal-node").attr("transform", d => `translate(${d.x}, ${d.y})`);
                    nodes.append("rect").attr("x", -60).attr("y", -40).attr("width", 120).attr("height", 80).attr("rx", 15).attr("fill", "white").attr("stroke", "#e2e8f0").attr("stroke-width", 2);
                    nodes.append("text").text(d => d.icon).attr("font-size", "40px").attr("text-anchor", "middle").attr("y", 5);
                    nodes.append("text").text(d => d.label).attr("text-anchor", "middle").attr("y", 30).style("font-size", "14px");
                    d3.select(nodes.nodes()[2]).style("opacity", 0).transition().duration(500).delay(500).style("opacity", 1);
                    const linksData = [{ source: nodesData[2], target: nodesData[0] }, { source: nodesData[2], target: nodesData[1] }];
                    g.selectAll(".causal-link").data(linksData).enter().insert("line", ".causal-node").attr("class", "causal-link").attr("x1", d => d.source.x).attr("y1", d => d.source.y + 40).attr("x2", d => d.target.x).attr("y2", d => d.target.y - 40).attr("stroke", "#94a3b8").style("opacity", 0).transition().duration(800).delay(1500).style("opacity", 1);
                }
            },
            // Scene 3: Drawing the Causal Map
            {
                text: "ä¸ºäº†ç†æ¸…æ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥ç”»ä¸€å¼ â€˜å› æœå…³ç³»å›¾â€™ã€‚è¿™å¼ å›¾æ¸…æ™°åœ°æ˜¾ç¤ºï¼Œå¤©æ°”æ‰æ˜¯æ ¹æœ¬åŸå› ï¼Œå®ƒåŒæ—¶å½±å“äº†å†°æ·‡æ·‹é”€é‡å’Œæººæ°´äººæ•°ã€‚",
                action: () => {
                    scenes[1].action(); // Reuse previous scene's drawing logic
                    setTimeout(() => {
                        const g = svg.select("g");
                        const nodesData = g.selectAll(".causal-node").data();
                        const fakeLink = g.append("line").attr("class", "correlation-link").attr("x1", nodesData[0].x + 60).attr("y1", nodesData[0].y).attr("x2", nodesData[1].x - 60).attr("y2", nodesData[1].y).attr("stroke", "#cbd5e1");
                        const cross = g.append("text").text("âŒ").attr("x", width/2).attr("y", nodesData[0].y + 10).attr("font-size", "30px").attr("text-anchor", "middle").attr("fill", "#ef4444");
                        fakeLink.style("opacity", 0).transition().duration(500).style("opacity", 1);
                        cross.style("opacity", 0).transition().duration(500).style("opacity", 1);
                    }, 500);
                }
            },
            // Scene 4: Conditional Independence
            {
                text: "å…³é”®ä¸€æ­¥ï¼šå®ç°â€œæ¡ä»¶ç‹¬ç«‹æ€§â€ã€‚é€šè¿‡â€˜æ§åˆ¶â€™å¤©æ°”è¿™ä¸ªå˜é‡ï¼ˆæ¯”å¦‚åªçœ‹35Â°Cçš„æ—¥å­ï¼‰ï¼Œæˆ‘ä»¬å°±é˜»æ–­äº†å®ƒå¸¦æ¥çš„æ··æ‚å½±å“ã€‚æ­¤æ—¶ï¼Œå†°æ·‡æ·‹å’Œæººæ°´è¿™ä¸¤ä¸ªå˜é‡å°±å˜å¾—ç›¸äº’ç‹¬ç«‹äº†ã€‚",
                action: () => {
                    scenes[2].action(); // Reuse previous scene's drawing logic
                    setTimeout(() => {
                        const g = svg.select("g");
                        const nodesData = g.selectAll(".causal-node").data();
                        const confounderNode = d3.select(g.selectAll(".causal-node").nodes()[2]);
                        confounderNode.append("rect").attr("class", "control-box").attr("x", -70).attr("y", -50).attr("width", 140).attr("height", 100).attr("rx", 20).attr("fill", "none").attr("stroke", "#60a5fa").attr("stroke-width", 4).attr("stroke-dasharray", "10 5").style("opacity", 0).transition().duration(800).style("opacity", 1);
                        g.append("text").text("æ§åˆ¶è¿™ä¸ªå˜é‡ï¼").attr("x", nodesData[2].x + 80).attr("y", nodesData[2].y).attr("fill", "#60a5fa").style("font-weight", "bold").style("opacity", 0).transition().duration(800).style("opacity", 1);
                    }, 1000);
                }
            },
            // Scene 5: The "What If" Experiment
            {
                text: "å› æœæ¨æ–­çš„æœ€ç»ˆç›®æ ‡æ˜¯å›ç­”â€œwhat ifâ€çš„é—®é¢˜ã€‚æ¯”å¦‚ï¼Œæˆ‘ä»¬ä¸»åŠ¨â€˜å¹²é¢„â€™ï¼Œåœ¨å¤§å†¬å¤©å¼ºåˆ¶æ‰€æœ‰äººåƒå†°æ·‡æ·‹ï¼Œæººæ°´äººæ•°ä¼šå¢åŠ å—ï¼Ÿè¿™ä¸ªâ€˜åäº‹å®â€™æ€è€ƒå¸®åŠ©æˆ‘ä»¬éªŒè¯äº†çœŸå®çš„å› æœè·¯å¾„ã€‚",
                action: () => {
                    svg.selectAll("*").remove();
                    const g = svg.append("g");
                    g.append("rect").attr("width", width).attr("height", height).attr("fill", "#e0f2fe");
                    for(let i=0; i<50; i++) { g.append("text").text("â„ï¸").attr("x", Math.random() * width).attr("y", Math.random() * height).attr("font-size", `${Math.random() * 20 + 10}px`).style("opacity", 0.7); }
                    const iceCreamNode = g.append("g").attr("transform", `translate(${width*0.3}, ${height*0.6})`);
                    iceCreamNode.append("text").text("ğŸ¦").attr("font-size", "60px").attr("text-anchor", "middle");
                    iceCreamNode.append("text").text("å¹²é¢„ï¼šå¼ºåˆ¶åƒå†°æ·‡æ·‹").attr("y", 50).attr("text-anchor", "middle").style("font-weight", "bold");
                    const interventionArrow = g.append("path").attr("d", `M ${width*0.4} ${height*0.6} C ${width*0.5} ${height*0.4}, ${width*0.6} ${height*0.8}, ${width*0.7} ${height*0.6}`).attr("stroke", "#fca5a5").attr("stroke-width", 4).attr("fill", "none").attr("stroke-dasharray", function() { return this.getTotalLength() }).attr("stroke-dashoffset", function() { return this.getTotalLength() }).transition().duration(1000).delay(500).attr("stroke-dashoffset", 0);
                    const drowningNode = g.append("g").attr("transform", `translate(${width*0.7}, ${height*0.6})`);
                    drowningNode.append("text").text("ğŸŠ").attr("font-size", "60px").attr("text-anchor", "middle");
                    drowningNode.append("text").text("ç»“æœï¼šæººæ°´äººæ•°ä¸å˜").attr("y", 50).attr("text-anchor", "middle").style("font-weight", "bold");
                    drowningNode.select("text:last-child").style("opacity", 0).transition().delay(1500).duration(500).style("opacity", 1);
                }
            },
            // Scene 6: Real-World Applications
            {
                text: "å› æœæ¨æ–­çš„åº”ç”¨æ— å¤„ä¸åœ¨ï¼Œå®ƒå¸®åŠ©æˆ‘ä»¬é€è¿‡æ•°æ®è¡¨è±¡ï¼Œæ‰¾åˆ°äº‹ç‰©ä¹‹é—´çœŸå®çš„å› æœè”ç³»ï¼Œä»è€Œåšå‡ºæ›´ç§‘å­¦çš„å†³ç­–ã€‚",
                action: () => {
                    svg.selectAll("*").remove();
                    const g = svg.append("g");
                    const apps = [
                        { name: "ç¯å¢ƒæ”¿ç­–è¯„ä¼°", icon: "ğŸŒ³", question: "æŸåœ°æ¨è¡Œé™å¡‘ä»¤åï¼Œæµ·æ´‹åƒåœ¾çœŸçš„å‡å°‘äº†å—ï¼Ÿè¿˜æ˜¯å› ä¸ºåŒæ—¶æœŸç»æµä¸‹è¡Œï¼Œå¯¼è‡´æ•´ä½“æ¶ˆè´¹é™ä½ï¼Ÿ" },
                        { name: "äº§å“ä¼˜åŒ– (A/Bæµ‹è¯•)", icon: "ğŸ“Š", question: "ç½‘ç«™æ”¹ç‰ˆåç”¨æˆ·å¢é•¿äº†ï¼Œæ˜¯æ–°è®¾è®¡çš„åŠŸåŠ³ï¼Œè¿˜æ˜¯å› ä¸ºæ°å¥½é‡ä¸Šäº†å­£èŠ‚æ€§æ¨å¹¿æ´»åŠ¨ï¼Ÿ" },
                        { name: "åŒ»ç–—ç ”ç©¶", icon: "ğŸ’Š", question: "æœç”¨æ–°è¯çš„ç—…äººåº·å¤æ›´å¿«ï¼Œæ˜¯è¯æ•ˆæ‰€è‡´ï¼Œè¿˜æ˜¯å› ä¸ºå…¥ç»„çš„ç—…äººæœ¬èº«å°±æ›´å¹´è½»ã€æ›´å¥åº·ï¼Ÿ" }
                    ];
                    
                    let appIndex = 0;
                    
                    function showApp(index) {
                        g.selectAll("*").remove(); // Clear previous app
                        
                        const app = apps[index];
                        const appGroup = g.append("g").attr("class", "app-group").style("opacity", 0);

                        appGroup.append("text")
                            .attr("x", width / 2)
                            .attr("y", height * 0.3)
                            .attr("text-anchor", "middle")
                            .attr("font-size", "80px")
                            .text(app.icon);

                        appGroup.append("text")
                            .attr("x", width / 2)
                            .attr("y", height * 0.5)
                            .attr("text-anchor", "middle")
                            .style("font-size", "22px")
                            .style("font-weight", "bold")
                            .attr("fill", "#334155")
                            .text(app.name);
                        
                        // Wrap text for the question
                        const questionText = appGroup.append("text")
                            .attr("x", width / 2)
                            .attr("y", height * 0.65)
                            .attr("text-anchor", "middle")
                            .style("font-size", "16px")
                            .attr("fill", "#475569");
                        
                        const words = app.question.split(/\s+/);
                        let line = '';
                        const lineHeight = 1.5; // ems
                        let tspan = questionText.append('tspan').attr('x', width / 2).attr('dy', '0em');
                        
                        words.forEach(word => {
                            const testLine = line + word + ' ';
                            tspan.text(testLine);
                            if (tspan.node().getComputedTextLength() > width * 0.8) {
                                tspan.text(line);
                                line = word + ' ';
                                tspan = questionText.append('tspan').attr('x', width/2).attr('dy', `${lineHeight}em`).text(line);
                            } else {
                                line = testLine;
                            }
                        });
                        tspan.text(line);

                        appGroup.transition().duration(500).style("opacity", 1)
                            .transition().delay(3500).duration(500).style("opacity", 0);
                    }
                    
                    showApp(appIndex);
                    appInterval = setInterval(() => {
                        appIndex = (appIndex + 1) % apps.length;
                        showApp(appIndex);
                    }, 4500);
                }
            }
        ];

        // --- Control Logic ---
        function runScene(sceneIndex) {
            // Clear interval from the last scene if it exists
            if (appInterval) {
                clearInterval(appInterval);
                appInterval = null;
            }

            sceneText.style("opacity", 0);
            
            setTimeout(() => {
                scenes[sceneIndex].action();
                sceneText.html(scenes[sceneIndex].text);
                sceneText.style("opacity", 1);
            }, 500);

            updateControls();
        }

        function updateControls() {
            sceneIndicator.text(`${currentScene + 1} / ${scenes.length}`);
            prevBtn.property("disabled", currentScene === 0);
            nextBtn.property("disabled", currentScene === scenes.length - 1);
        }

        nextBtn.on("click", () => {
            if (currentScene < scenes.length - 1) {
                currentScene++;
                runScene(currentScene);
            }
        });

        prevBtn.on("click", () => {
            if (currentScene > 0) {
                currentScene--;
                runScene(currentScene);
            }
        });

        // --- Initial Run ---
        runScene(0);

    </script>
</body>
</html>
